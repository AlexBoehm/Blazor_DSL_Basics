using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace DSLMethodsGenerator
{
    class Program
    {
        static void Main(string[] args) {
            // ExportBlazorEvents();
            
            GenerateTagMethods();
            GenerateEventMethods();


            
        }

        private static void GenerateTagMethods() {
            var allTags = FilterLines(File.ReadAllLines("HTML Tags.txt"));        
            var voidTags = FilterLines(File.ReadAllLines("HTML Void Elements.txt"));
            var reservedCSharpKeywords = FilterLines(File.ReadAllLines("CSharpReservedKeywords.txt"));
            var tagsWithText = FilterLines(File.ReadAllLines("HTML Tags with text.txt"));

            var tags =
                from tag in allTags
                let isVoidTag = voidTags.Contains(tag)
                let isReservedKeyword = reservedCSharpKeywords.Contains(tag)
                let withText = tagsWithText.Contains(tag)

                select (tag: tag, isVoidTag: isVoidTag, isReservedKeyword: isReservedKeyword, withText: withText);

            var source = @"/* This file ist generated by the program DSLMethodsGenerator. DO NOT EDIT IT MANUALLY! */

using System.Collections.Generic;
using System.Linq;

namespace BlazorDSL {
    public static partial class Html {
        " +
        string.Join(Environment.NewLine, tags.SelectMany(tag => BuildTagMethods(tag.tag, tag.isVoidTag, tag.isReservedKeyword, tag.withText))) +
        @"
    }
}
";
            File.WriteAllText(@"..\..\..\..\Lib\HTML_Tags.cs", source);
        }

        private static IEnumerable<string> BuildTagMethods(string tag, bool isVoidElement, bool isReservedKeyword, bool withText) {
            var methodName = isReservedKeyword
                ? "@" + tag
                : tag;

            if(!isVoidElement)
                yield return @$"
        public static Node {methodName}(Attribute[] attributes, params Node[] inner)
            => new TagNode(""{tag}"", attributes, inner);";

            if (!isVoidElement)
                yield return $@"
        public static Node {methodName}(params Node[] inner)
            => new TagNode(""{tag}"", inner);";

            if (!isVoidElement)
                yield return $@"
        public static Node {methodName}(IEnumerable<Node> inner)
            => new TagNode(""{tag}"", inner.ToArray());";

            if (isVoidElement)
                yield return @$"
        public static Node {methodName}(Attribute[] attributes)
            => new TagNode(""{tag}"", attributes);";

            if(!isVoidElement && withText)
                yield return $@"
        public static Node {methodName}(Attribute[] attributes, string text)
            => new TagNode(""{tag}"", attributes, Html.text(text));";

            if (!isVoidElement && withText)
                yield return $@"
        public static Node {methodName}(string text)
            => new TagNode(""{tag}"", Html.text(text));";
        }

        private static string[] FilterLines(string[] lines)
            => lines
                .Where(line => !line.Trim().StartsWith("#"))
                .Where(line => !string.IsNullOrWhiteSpace(line))
                .ToArray();

        private static void GenerateEventMethods() {
            var eventMehodNames = (
                from line in File.ReadLines("Blazor Events.txt")
                where !line.Trim().StartsWith("#")
                let parts = line.Trim().Split("\t")
                select (method: parts[0], attribute: parts[1])
            ).ToDictionary(x => x.attribute);

            var eventHandlerAttributes = ReadEventHandlerAttributes();

            var methods =
                from attribute in eventHandlerAttributes
                where eventMehodNames.ContainsKey(attribute.AttributeName)
                let methodNameConfiguration = eventMehodNames[attribute.AttributeName]
                select (method: methodNameConfiguration.method, attribute: attribute.AttributeName, eventType: attribute.EventArgsType)
                ;

            var source = @"/* This file ist generated by the program DSLMethodsGenerator. DO NOT EDIT IT MANUALLY! */

using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web;
using System;

namespace BlazorDSL {
    static partial class Html {" +
    string.Join(Environment.NewLine, methods.Select(item => BuildMethod(item.method, item.attribute, item.eventType))) +
    @"
    }
}
";

            File.WriteAllText(@"..\..\..\..\Lib\HTML_Events.cs", source);
        }

        // private static 

        private static string BuildMethod(string methodName, string attibuteName, Type eventType) =>
        $@"
        public static Attribute {methodName}(object sender, Action<{eventType.Name}> callback)
            => new Attribute(
                ""{attibuteName}"",
                EventCallback.Factory.Create(sender, callback)
            );";
        
        private static void ExportBlazorEvents() {
            IEnumerable<EventHandlerAttribute> attributes = ReadEventHandlerAttributes();

            File.WriteAllLines(
                "Blazor Events.txt",
                from item in attributes
                select $"{item.AttributeName}\t{item.AttributeName}\t{item.EventArgsType}"
            );

            foreach (var item in attributes) {
                Console.WriteLine($"{item.AttributeName} {item.EventArgsType}");
            }
        }

        private static IEnumerable<EventHandlerAttribute> ReadEventHandlerAttributes() {
            return typeof(EventHandlers).GetCustomAttributes(
                typeof(EventHandlerAttribute), true
            )
            .Cast<EventHandlerAttribute>();
        }
    }
}
